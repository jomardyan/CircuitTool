# I2C Protocol Guide

## Introduction

Inter-Integrated Circuit (I2C) is a serial communication protocol developed by Philips Semiconductor (now NXP). It's designed for short-distance communication between microcontrollers and peripheral devices using only two wires.

## Protocol Overview

### Key Features
- **Two-wire interface**: SDA (Serial Data) and SCL (Serial Clock)
- **Multi-master, multi-slave** architecture
- **7-bit or 10-bit addressing** (7-bit is most common)
- **Half-duplex communication**
- **Built-in arbitration** for multi-master scenarios
- **Acknowledgment mechanism** for error detection

### Signal Lines
- **SDA (Serial Data Line)**: Bidirectional data transmission
- **SCL (Serial Clock Line)**: Clock signal generated by master
- **Pull-up resistors**: Required on both lines (typically 4.7kΩ to 10kΩ)

## Protocol Operation

### Start and Stop Conditions
- **Start Condition**: SDA goes LOW while SCL is HIGH
- **Stop Condition**: SDA goes HIGH while SCL is HIGH
- **Repeated Start**: Start condition without preceding stop condition

### Data Transfer Format
```
[START] [7-bit Address + R/W bit] [ACK] [Data Byte] [ACK] ... [STOP]
```

### Clock Speeds
- **Standard Mode**: 100 kbit/s
- **Fast Mode**: 400 kbit/s
- **Fast Mode Plus**: 1 Mbit/s
- **High-speed Mode**: 3.4 Mbit/s

## Hardware Configuration

### Pull-up Resistor Calculation
```
R_pullup = (Vcc - 0.4V) / (3mA × number_of_devices)
```

Typical values:
- **100 kHz**: 4.7kΩ - 10kΩ
- **400 kHz**: 2.2kΩ - 4.7kΩ
- **1 MHz**: 1kΩ - 2.2kΩ

### Bus Capacitance Limits
- **Standard/Fast Mode**: 400pF maximum
- **Fast Mode Plus**: 550pF maximum

## Programming Examples

### Arduino I2C Master (Writing Data)
```cpp
#include <Wire.h>

void setup() {
  Wire.begin(); // Initialize as master
  Serial.begin(9600);
}

void loop() {
  Wire.beginTransmission(0x48); // Address 0x48
  Wire.write(0x01); // Register address
  Wire.write(0xFF); // Data to write
  byte error = Wire.endTransmission();
  
  if (error == 0) {
    Serial.println("Success");
  } else {
    Serial.print("Error: ");
    Serial.println(error);
  }
  
  delay(1000);
}
```

### Arduino I2C Master (Reading Data)
```cpp
void readSensor() {
  Wire.beginTransmission(0x48);
  Wire.write(0x00); // Register to read
  Wire.endTransmission(false); // Repeated start
  
  Wire.requestFrom(0x48, 2); // Request 2 bytes
  
  if (Wire.available() >= 2) {
    byte highByte = Wire.read();
    byte lowByte = Wire.read();
    uint16_t value = (highByte << 8) | lowByte;
    Serial.print("Value: ");
    Serial.println(value);
  }
}
```

### Arduino I2C Slave
```cpp
#include <Wire.h>

void setup() {
  Wire.begin(0x48); // Initialize as slave with address 0x48
  Wire.onReceive(receiveEvent);
  Wire.onRequest(requestEvent);
}

void receiveEvent(int bytes) {
  while (Wire.available()) {
    byte data = Wire.read();
    // Process received data
  }
}

void requestEvent() {
  Wire.write(42); // Send data to master
}
```

## Common Issues and Troubleshooting

### Bus Hanging
- **Cause**: Slave device holding SDA low
- **Solution**: Send 9 clock pulses to reset slave state

### Communication Failures
- **Check pull-up resistors**: Too high/low values
- **Verify addresses**: Ensure no conflicts
- **Bus capacitance**: Too many devices or long wires
- **Power supply noise**: Use proper decoupling capacitors

### Address Conflicts
- Use I2C scanner to detect devices:
```cpp
for (byte address = 1; address < 127; address++) {
  Wire.beginTransmission(address);
  if (Wire.endTransmission() == 0) {
    Serial.print("Device found at 0x");
    Serial.println(address, HEX);
  }
}
```

## Best Practices

1. **Always use pull-up resistors** on SDA and SCL lines
2. **Keep bus length short** (< 1 meter for standard speeds)
3. **Use proper PCB layout** with ground planes and short traces
4. **Implement timeouts** in software to prevent hanging
5. **Use level shifters** when mixing different voltage levels
6. **Document device addresses** to avoid conflicts

## Applications

- **Sensor interfaces**: Temperature, pressure, accelerometers
- **EEPROM/Flash memory** communication
- **Real-time clocks (RTC)**
- **LCD displays** with I2C backpacks
- **GPIO expanders**
- **DAC/ADC** converters

## Related Protocols

- **SMBus**: System Management Bus (subset of I2C)
- **PMBus**: Power Management Bus (based on SMBus)
- **IPMB**: Intelligent Platform Management Bus
