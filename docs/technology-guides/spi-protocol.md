# SPI Protocol Guide

## Introduction

Serial Peripheral Interface (SPI) is a synchronous serial communication protocol developed by Motorola. It's widely used for short-distance communication between microcontrollers and peripheral devices, offering high-speed data transfer with simple implementation.

## Protocol Overview

### Key Features
- **Full-duplex communication**: Simultaneous data transmission and reception
- **Master-slave architecture**: One master controls multiple slaves
- **High-speed operation**: Can operate at several MHz
- **Simple hardware interface**: Uses 4 signal lines
- **No addressing required**: Chip select lines determine active slave

### Signal Lines
- **MOSI (Master Out Slave In)**: Data from master to slave
- **MISO (Master In Slave Out)**: Data from slave to master
- **SCK/SCLK (Serial Clock)**: Clock signal generated by master
- **SS/CS (Slave Select/Chip Select)**: Selects active slave device

## Protocol Operation

### Data Transfer
- Master generates clock signal (SCK)
- Data is transferred on clock edges (rising or falling)
- Each clock pulse transfers one bit
- 8-bit, 16-bit, or 32-bit transfers are common

### Clock Polarity and Phase (CPOL/CPHA)
Four SPI modes based on clock polarity and phase:

| Mode | CPOL | CPHA | Clock Idle | Data Sample Edge |
|------|------|------|------------|------------------|
| 0    | 0    | 0    | Low        | Rising           |
| 1    | 0    | 1    | Low        | Falling          |
| 2    | 1    | 0    | High       | Falling          |
| 3    | 1    | 1    | High       | Rising           |

### Timing Diagram
```
SCK     ____/‾‾‾‾\____/‾‾‾‾\____/‾‾‾‾\____
MOSI    ----< D7 >----< D6 >----< D5 >----
MISO    ----< D7 >----< D6 >----< D5 >----
CS      \___________________________/‾‾‾‾
```

## Hardware Configuration

### Basic Connection
```
Master              Slave
MOSI  ------------> MOSI/DI
MISO  <------------ MISO/DO
SCK   ------------> SCK
CS    ------------> CS
```

### Multi-Slave Configuration
```
Master
  |
  +-- MOSI --> Slave 1 MOSI
  |            Slave 2 MOSI
  |            Slave 3 MOSI
  |
  +-- MISO <-- Slave 1 MISO (tri-state)
  |            Slave 2 MISO (tri-state)
  |            Slave 3 MISO (tri-state)
  |
  +-- SCK  --> Slave 1 SCK
  |            Slave 2 SCK
  |            Slave 3 SCK
  |
  +-- CS1  --> Slave 1 CS
  +-- CS2  --> Slave 2 CS
  +-- CS3  --> Slave 3 CS
```

## Clock Speed Considerations

### Maximum Clock Frequencies
- **Standard SPI**: 1-10 MHz typical
- **High-speed SPI**: 50+ MHz possible
- **Limited by**: PCB traces, device capabilities, signal integrity

### Clock Speed Calculation
```
Max_Clock = 1 / (2 × (propagation_delay + setup_time + hold_time))
```

## Programming Examples

### Arduino SPI Master
```cpp
#include <SPI.h>

const int chipSelectPin = 10;

void setup() {
  pinMode(chipSelectPin, OUTPUT);
  digitalWrite(chipSelectPin, HIGH); // Deselect slave
  
  SPI.begin();
  SPI.setClockDivider(SPI_CLOCK_DIV16); // 1MHz @ 16MHz Arduino
  SPI.setDataMode(SPI_MODE0);
  SPI.setBitOrder(MSBFIRST);
}

void loop() {
  // Send data to slave
  digitalWrite(chipSelectPin, LOW);   // Select slave
  byte response = SPI.transfer(0x42); // Send 0x42, receive response
  digitalWrite(chipSelectPin, HIGH);  // Deselect slave
  
  delay(1000);
}
```

### Arduino SPI Multi-byte Transfer
```cpp
void writeRegister(byte address, byte value) {
  digitalWrite(chipSelectPin, LOW);
  SPI.transfer(address | 0x80); // Write command (set MSB)
  SPI.transfer(value);
  digitalWrite(chipSelectPin, HIGH);
}

byte readRegister(byte address) {
  digitalWrite(chipSelectPin, LOW);
  SPI.transfer(address & 0x7F); // Read command (clear MSB)
  byte value = SPI.transfer(0x00); // Dummy byte to receive data
  digitalWrite(chipSelectPin, HIGH);
  return value;
}
```

### Arduino SPI Slave (using interrupt)
```cpp
#include <SPI.h>

volatile boolean received = false;
volatile byte receivedData;

void setup() {
  pinMode(MISO, OUTPUT); // Set MISO as output
  SPCR |= _BV(SPE);      // Enable SPI in slave mode
  SPCR |= _BV(SPIE);     // Enable SPI interrupt
}

// SPI interrupt routine
ISR(SPI_STC_vect) {
  receivedData = SPDR;   // Read received data
  received = true;
  SPDR = 0x55;          // Send response data
}

void loop() {
  if (received) {
    // Process received data
    received = false;
  }
}
```

## Advanced Features

### SPI with DMA (Direct Memory Access)
```cpp
// STM32 example with DMA
void setupSPIDMA() {
  // Configure SPI peripheral
  SPI1->CR1 |= SPI_CR1_MSTR;  // Master mode
  SPI1->CR2 |= SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN; // Enable DMA
  
  // Configure DMA channels
  // TX DMA configuration
  DMA1_Channel3->CPAR = (uint32_t)&SPI1->DR;
  DMA1_Channel3->CMAR = (uint32_t)txBuffer;
  DMA1_Channel3->CNDTR = bufferSize;
  
  // RX DMA configuration
  DMA1_Channel2->CPAR = (uint32_t)&SPI1->DR;
  DMA1_Channel2->CMAR = (uint32_t)rxBuffer;
  DMA1_Channel2->CNDTR = bufferSize;
}
```

### Daisy Chain Configuration
```cpp
// For shift registers or similar devices
void daisyChainWrite(byte* data, int length) {
  digitalWrite(chipSelectPin, LOW);
  
  for (int i = length - 1; i >= 0; i--) {
    SPI.transfer(data[i]); // Send from last to first
  }
  
  digitalWrite(chipSelectPin, HIGH); // Latch data
}
```

## Common Applications

### SD Card Interface
```cpp
#include <SD.h>

void setupSDCard() {
  if (!SD.begin(chipSelectPin)) {
    Serial.println("SD card initialization failed");
    return;
  }
  
  File dataFile = SD.open("datalog.txt", FILE_WRITE);
  if (dataFile) {
    dataFile.println("Timestamp,Temperature,Humidity");
    dataFile.close();
  }
}
```

### TFT Display Control
```cpp
void writeCommand(byte cmd) {
  digitalWrite(dcPin, LOW);  // Command mode
  digitalWrite(csPin, LOW);
  SPI.transfer(cmd);
  digitalWrite(csPin, HIGH);
}

void writeData(byte data) {
  digitalWrite(dcPin, HIGH); // Data mode
  digitalWrite(csPin, LOW);
  SPI.transfer(data);
  digitalWrite(csPin, HIGH);
}
```

## Troubleshooting

### Common Issues
1. **No response from slave**
   - Check connections (MOSI, MISO, SCK, CS)
   - Verify SPI mode settings
   - Confirm slave address/CS signal

2. **Corrupted data**
   - Check clock frequency (too fast for slave)
   - Verify signal integrity with oscilloscope
   - Ensure proper grounding

3. **Timing issues**
   - Adjust setup/hold times
   - Use appropriate clock divider
   - Check PCB trace lengths

### Debug Techniques
```cpp
void debugSPI() {
  Serial.print("SPI Status: ");
  Serial.println(SPSR, BIN);
  Serial.print("SPI Control: ");
  Serial.println(SPCR, BIN);
  
  // Test loopback (connect MOSI to MISO)
  byte testData = 0xAA;
  byte received = SPI.transfer(testData);
  Serial.print("Sent: 0x");
  Serial.print(testData, HEX);
  Serial.print(", Received: 0x");
  Serial.println(received, HEX);
}
```

## Performance Optimization

### High-Speed Considerations
1. **Use shorter traces** on PCB
2. **Add termination resistors** for long traces
3. **Use differential signaling** for very high speeds
4. **Implement proper grounding** and power decoupling
5. **Consider signal slew rate** and EMI

### Buffer Management
```cpp
class SPIBuffer {
private:
  byte buffer[256];
  int writeIndex = 0;
  int readIndex = 0;
  
public:
  void write(byte data) {
    buffer[writeIndex] = data;
    writeIndex = (writeIndex + 1) % 256;
  }
  
  byte read() {
    byte data = buffer[readIndex];
    readIndex = (readIndex + 1) % 256;
    return data;
  }
  
  bool available() {
    return writeIndex != readIndex;
  }
};
```

## Best Practices

1. **Use appropriate clock speed** for your application
2. **Implement proper error handling** and timeouts
3. **Use hardware CS** when possible for timing accuracy
4. **Keep traces short** and use ground planes
5. **Document SPI mode** used for each device
6. **Use pull-up resistors** on CS lines
7. **Consider power sequencing** for complex systems

## Comparison with Other Protocols

| Feature | SPI | I2C | UART |
|---------|-----|-----|------|
| Wires | 4+ | 2 | 2 |
| Speed | High (MHz) | Medium (kHz) | Medium (kHz) |
| Complexity | Medium | High | Low |
| Multi-master | No | Yes | No |
| Addressing | CS lines | Address bits | None |
| Duplex | Full | Half | Full |
